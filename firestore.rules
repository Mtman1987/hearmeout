/**
 * # Firestore Security Rules
 *
 * ## Core Philosophy
 * This ruleset enforces a security model centered around user ownership and public/private
 * resource states. User data is strictly private and owned by the user. Core resources, like
 * Rooms, can be either public (readable by any authenticated user) or private (readable

 * only by the owner). Writes are always restricted to authorized users, primarily the
 * resource owner.
 *
 * ## Data Structure
 * The data is organized into top-level collections for primary entities:
 * - `/users/{userId}`: Stores all user profile data.
 * - `/rooms/{roomId}`: Stores all room data. This collection has nested subcollections
 *   for room-specific content.
 * - `/room_users/{roomUserId}`: A join collection to track which users are in which rooms.
 *
 * Subcollections are nested under their parent Room to establish a clear relational
 * hierarchy and enable inherited access control:
 * - `/rooms/{roomId}/media/{mediaId}`
 * - `/rooms/{roomId}/moderation_logs/{moderationLogId}`
 *
 * ## Key Security Decisions
 * - **Deny All by Default**: Access is explicitly granted; anything not specified is denied.
 * - **User Data Privacy**: Users can only access their own document in the `/users`
 *   collection. Listing users is disabled to prevent user enumeration.
 * - **Room Access Control**: Rooms have an `isPrivate` flag. Public rooms are readable by any
 *   signed-in user, while private rooms are only accessible by their owner. All write
 *   operations on a room are restricted to the `ownerId` specified in the document.
 * - **Denormalization for Authorization**: Room documents contain an `ownerId` field. This
 *   is critical for performant and secure authorization, as it allows rules to check
 *   ownership without needing extra database reads.
 * - **Server-Side Only Collections**: The `moderation_logs` subcollection is designated as
 *   read-only for clients (specifically, the room owner). All writes must be performed by
 *   a trusted server environment to prevent tampering with audit logs.
 * - **No Listing Memberships**: Listing the `/room_users` collection is disallowed to
 *   protect the privacy of who is a member of which room.
 *
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the provided userId.
     * This is the primary function for establishing document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * Checks for ownership on an existing document. Used for update/delete.
     * Enforces that the document must exist before the operation.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
    
    /**
     * Validates that the ownerId of an incoming document matches the creator.
     */
    function isIncomingDataOwner(fieldName) {
      return request.resource.data[fieldName] == request.auth.uid;
    }
    
    /**
     * Validates that a specific field is unchanged during an update.
     * Critical for preventing users from re-assigning ownership.
     */
    function isImmutable(fieldName) {
      return request.resource.data[fieldName] == resource.data[fieldName];
    }
    
    /**
     * Retrieves parent Room data for subcollection rules.
     */
    function getRoomData(roomId) {
      return get(/databases/$(database)/documents/rooms/$(roomId)).data;
    }

    /**
     * Checks if the requesting user is the owner of a parent room.
     */
    function isRoomOwner(roomId) {
      return isOwner(getRoomData(roomId).ownerId);
    }
    
    /**
     * Checks if a parent room is public.
     */
    function isPublicRoom(roomId) {
      return getRoomData(roomId).isPrivate == false;
    }

    // ------------------------------------------------------------------------
    // User Profiles
    // ------------------------------------------------------------------------

    /**
     * @description
     *   Manages user profile data. Each user has exclusive control over their own
     *   document. Listing all users is forbidden.
     * @path
     *   /users/{userId}
     * @allow
     *   (update) A user (auth.uid: 'user_abc') updates their own profile document
     *   at `/users/user_abc`.
     * @deny
     *   (get) A user (auth.uid: 'user_xyz') tries to read the profile document at
     *   `/users/user_abc`.
     * @principle
     *   Restricts access to a user's own data tree (Path-based Ownership).
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Prevent user enumeration
      allow create: if isOwner(userId) && isIncomingDataOwner('id');
      allow update: if isExistingOwner(userId) && isImmutable('id');
      allow delete: if isExistingOwner(userId);
    }

    // ------------------------------------------------------------------------
    // Rooms & Subcollections
    // ------------------------------------------------------------------------

    /**
     * @description
     *   Manages chat rooms. Public rooms are visible to all signed-in users, but
     *   private rooms are only visible to their owner. Only the owner can modify
     *   or delete a room.
     * @path
     *   /rooms/{roomId}
     * @allow
     *   (get) Any signed-in user reads a room where `isPrivate` is false.
     * @deny
     *   (update) A user tries to change the `ownerId` of a room they own.
     * @principle
     *   Enforces document ownership for writes and uses a data field (`isPrivate`)
     *   to control read access for the public.
     */
    match /rooms/{roomId} {
      allow get: if isSignedIn() && (resource.data.isPrivate == false || isOwner(resource.data.ownerId));
      allow list: if isSignedIn(); // Client queries must filter for public rooms
      allow create: if isSignedIn() && isIncomingDataOwner('ownerId');
      allow update: if isExistingOwner(resource.data.ownerId) && isImmutable('ownerId');
      allow delete: if isExistingOwner(resource.data.ownerId);

      /**
       * @description
       *   Manages media within a room. Media in public rooms can be viewed by anyone.
       *   Media can be added to public rooms by any user, or to private rooms by the owner.
       *   Only the room owner or the original uploader can modify/delete media.
       * @path
       *   /rooms/{roomId}/media/{mediaId}
       * @allow
       *   (create) A user adds a new media item to a public room.
       * @deny
       *   (delete) A user tries to delete a media item they did not upload from a room
       *   they do not own.
       * @principle
       *   Inherits read access from the parent room and uses a combination of parent
       *   ownership and item ownership for writes.
       */
      match /media/{mediaId} {
        allow get: if isSignedIn() && (isPublicRoom(roomId) || isRoomOwner(roomId));
        allow list: if isSignedIn() && (isPublicRoom(roomId) || isRoomOwner(roomId));
        allow create: if isSignedIn() && (isPublicRoom(roomId) || isRoomOwner(roomId))
                        && isIncomingDataOwner('uploadedByUserId')
                        && request.resource.data.roomId == roomId;
        allow update: if (resource != null) && (isRoomOwner(roomId) || isOwner(resource.data.uploadedByUserId))
                        && isImmutable('uploadedByUserId') && isImmutable('roomId');
        allow delete: if (resource != null) && (isRoomOwner(roomId) || isOwner(resource.data.uploadedByUserId));
      }

      /**
       * @description
       *   Stores moderation logs for a room. These are read-only for the room owner
       *   and cannot be created, updated, or deleted by any client.
       * @path
       *   /rooms/{roomId}/moderation_logs/{moderationLogId}
       * @allow
       *   (get) The room owner (auth.uid matches room's `ownerId`) reads a log entry.
       * @deny
       *   (create) Any client, including the room owner, tries to create a new log entry.
       * @principle
       *   Secures an audit trail by making it immutable from the client-side.
       *   Writes must be performed by a trusted server process.
       */
      match /moderation_logs/{moderationLogId} {
        allow get: if isRoomOwner(roomId);
        allow list: if isRoomOwner(roomId);
        allow create: if false; // Server-side writes only
        allow update: if false; // Immutable logs
        allow delete: if false; // Immutable logs
      }
    }

    // ------------------------------------------------------------------------
    // Room Membership
    // ------------------------------------------------------------------------
    
    /**
     * @description
     *   Represents a user's membership in a room. Users can create (join) or
     *   delete (leave) their own membership records. Listing all memberships is
     *   disallowed to protect user privacy.
     * @path
     *   /room_users/{roomUserId}
     * @allow
     *   (create) A user creates a `room_user` document where the `userId` field
     *   matches their own auth UID.
     * @deny
     *   (list) Any user tries to list documents in the collection.
     * @principle
     *   Enforces self-service management of relational data. The user controls
     *   their own link to another resource.
     */
    match /room_users/{roomUserId} {
      allow get: if isSignedIn() && isOwner(resource.data.userId);
      allow list: if false; // Prevent leaking who is in what room
      allow create: if isSignedIn() && isIncomingDataOwner('userId');
      allow update: if false; // Membership is not updatable, only created/deleted
      allow delete: if isExistingOwner(resource.data.userId);
    }
  }
}